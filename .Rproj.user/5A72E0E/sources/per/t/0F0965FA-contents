## ---------------------------
##
## Script name: clean_data.R
##
## Purpose of script: Get and prepare data from PBDB
##
## Author: Dr Lewis Jones
##
## Date Created: 2020-11-25
##
## Copyright (c) Lewis Jones, 2020
## Email: LewisA.Jones@outlook.com
##
## ---------------------------
#Load packages
library(dplyr)
library(RCurl)
library(dggridR)
#library(data.table)
source("./R/options.R")
source("./R/functions/LatBins.R")
## ---------------------------

RCurl::curlSetOpt(3000)

## ---------------------------
#get pbdb data
API = paste("https://paleobiodb.org/data1.2/occs/list.csv?base_name=",groups,
            "&taxon_reso=", taxonomic_resolution, 
            "&ident=",identification,
            "&taxon_status=", taxon_status,
            "&idqual=", modifiers,
            "&pres=", preservation,
            "&interval=", study_period,
            "&envtype=", environment,
            "&show=", show,
            sep = "")

data <- RCurl::getURL(url = API, ssl.verifypeer = FALSE)

data <- read.csv(textConnection(data))
#save raw data
write.csv(data, "./data/pbdb_data.csv")

## ---------------------------
#clean up data

#remove data without paleocoordinates
data <- dplyr::filter(data, !is.na(paleolat) & !is.na(paleolat))

#Retain only most recent genus id
data$genus <- sub(" .*", "", data$genus)

#remove singletons
singletons <- table(data$genus)
singletons <- names(singletons[singletons == 1])
data <- data %>% filter(!genus %in% singletons)

#remove occurrences with coarse geographic scale (i.e. basin-level)
data <- subset(data, !geogscale == "basin")

## ---------------------------
#temporally bin data
data$duration <- data$max_ma - data$min_ma
data$mid_ma <- (data$max_ma + data$min_ma)/2

#create empty columns for populating
data$stage_bin <- NA
data$stage_overlap <- NA

#load stage bins
stages <- read.csv("./data/stage_bins.csv")

for(i in 1:nrow(stages)){
  overlap <- apply(cbind(data$max_ma, stages$max_ma[i]), 1, FUN=min) - apply(cbind(data$min_ma, stages$min_ma[i]), 1, FUN=max)
  data$stage_bin[which(overlap >= data$duration/2)] <- as.numeric(stages$mid_ma[i])
  data$stage_overlap[which(overlap >= data$duration/2)] <- overlap[which(overlap >= data$duration/2)]
}

data <- subset(data, !is.na(stage_bin))

## ---------------------------
#latitudinal bins
latbins <- LatBins(size = lat_bins)
#save lat bins for later
write.csv(latbins, "./data/lat_bins.csv", row.names = FALSE)
#create empty column
data$lat_bin <- NA

for(i in 1:nrow(latbins)){
  vec <- which(data$paleolat < latbins$max[i] & data$paleolat > latbins$min[i])
  data$lat_bin[vec] <- as.numeric(latbins$mid[i])
}

## ---------------------------
#spatially bin data
#create empty column
data$spatial_bin <- NA
#generate equal area grid
dggs <- dggridR::dgconstruct(spacing = spacing, resround='nearest', metric = TRUE)
#assign to spatial bins
data$spatial_bin <- unlist(dggridR::dgGEO_to_SEQNUM(dggs = dggs, in_lon_deg = data$paleolng, in_lat_deg = data$paleolat))
#extract centroid coordinate of spatial grid
coords <- cbind.data.frame(dgSEQNUM_to_GEO(dggs,data$spatial_bin))
#bind to data
data <- cbind.data.frame(data, coords)
## ---------------------------

#save data frame
write.csv(data, "./data/cleaned_pbdb_data.csv", row.names = FALSE)
